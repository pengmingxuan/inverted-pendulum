\documentclass[12pt]{article}
\newcommand{\ts}{\textsuperscript}

\usepackage[margin=1in]{geometry}
\usepackage{caption}
\usepackage{cite}
\usepackage{subcaption,graphicx}
\usepackage{lineno, blindtext}
\usepackage{float}
\usepackage{color}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage{mathtools}
\usepackage{pdfpages}
\setlength{\parindent}{0pt}
\newcommand{\forceindent}{\leavevmode{\parindent=1em\indent}}
%\usepackage{siunitx}
\usepackage{chronology}
\usepackage{circuitikz,siunitx}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage[ruled,vlined]{algorithm2e}
%embed c code
\usepackage{minted}

\title{\textbf{Real-Time Embedded Control System\\ for an Inverted Pendulum\\} \bigskip MSE 450\\Final Project Report}
\author{\\ \\ \\\textit{Self Proposed Project Group 1}\\ Rachel George -  301288581 \\ Ryan Fielding - 301284210}
\date{April $10^{th}$, 2020}

\begin{document}

\maketitle
\begin{center}
    \includegraphics[width=.60\linewidth, angle = 90]{figures/pendulum.JPG}
\end{center}

\newpage

{\Large \textbf{Abstract\\\\}}
This report outlines the project completion for the MSE 450 (Real-time and Embedded Control Systems) course project, which has been developed in conjunction with the MSE 483 (Modern Control Systems) course project. In short, the system implements a state space model observer based feedback control system, written in \textbf{C}, via the course Tiva C TM4C123GH6PM microcontroller, with the goal of stabilizing an inverted pendulum across various small impulses or step inputs. This inverted pendulum system has been built from the parts of a broken Canon printer donated by a past high school teacher. The main components taken from this printer include the printer cartridge track (for the cart), a DC motor and belt drive, as well as a linear optical encoder. The pendulum is mounted to a potentiometer to measure the angle of the pendulum, $\theta$, which will be mounted to the cart, whose position, $x$, will be measured (inc/decremented) by the optical encoder. To effectively implement this system, the Tiva C microcontroller initialization has been completed early on, in order to allow for state model controller testing and to ensure a stabilized pendulum by the project deadline. The initialization will consist of:
\begin{itemize}
\item 2 digital inputs for the optical quadrature encoder outputs, channels A and B, which will increment and decrement the cart position via the quadrature encoder interface.
\item 1 analog input for the angle of the pendulum via a 10k$\Omega$ potentiometer and ADC.
\item 2 PWM outputs for the actuation and control of the 12V, 1A DC motor through an H-bridge (TA7267BP) interface board, connected to the cart via a belt drive.
\item Switch 1 (SW1) digital input to trigger interrupts for running/stopping the system and recording target $x,\theta$.
\end{itemize}
Initialization of the microcontroller and all working components was completed by March $15^{th}$, 2020, to allow enough time for state model development and testing. This includes but is not limited to, measurement of $\theta \textrm{ and } x$, ensuring that the position increments properly at high speeds, and adequate position control of the DC motor powered cart. At this point, the observer based state feedback controller has been implemented, and vigorously tested. The final control system has been completed and tested by March $30^{th}$, 2020, however further gain tuning is required for stable control of the pendulum. Additionally, controller tuning is only comprised of software changes.\bigskip

In addition to the aforementioned goals and objectives, other features have also been implemented to further enhance this real time control system. Firstly, UART communication through USB to allow for data transmission and plotting of $x, \dot{x}, \theta, \dot{\theta}$ states of the system, in MATLAB. This enables the accurate realization of system response times to different inputs. Additionally, MATLAB functions are being used to place stable system poles, and tune the \textit{Luenberger} observer. After tuning, another function exports an \textbf{obsv.h} file containing the system gains and matrices for observer feedback, which is then tested, plotted and analyzed. This process is currently in progress and is nearing completion. All development can be seen on \textit{Github}, linked in the references. For this report and project demo video, a simple P controller has been implemented.

\newpage
\tableofcontents
\listoffigures
\newpage

\section{Introduction}
\subsection{Overview}
This real time embedded control involves the concept of stabilizing an inverted pendulum; an unstable system which if otherwise not intervened with by engineered, calculated actuation, will become unbalanced due to gravity and the displacement of the pendulum's centre of gravity from a set point. This experiment encapsulates a true real-time system which integrates an embedded microcontroller system to control and react within stringent response-time constraints.
\\\\
Physically the system is built from reused spare parts of a broken Canon printer, donated from one of the team member's previous high school teachers. Parts salvaged include a linear guide rail, a 12V, 1A DC motor and a linear optical encoder. The linear encoder was later replaced as it was discovered to be burnt out. A basic potentiometer is be used to measure the angle of the pendulum. The platform chosen to control this system is the Tiva TM4C123GH6PM microcontroller. It is implemented with an H-bridge motor interface board to drive the DC motor, and the required sensors. Additionally, software development is done in Code Composer Studio written in C.
\subsection{Control System Background}
The controller's commands is dependent on the feedback of the state system; this ultimately entails a closed loop system. As exemplified below (Figure \ref{fig:loops}), it is the difference between a closed loop system and an open loop system. Simply put, an open loop system has no indication of its perpetuated error that it may be incurring, therefore feedback loops or closed loop systems can respond accordingly to disturbances that deviate the output from the target value.
\begin{figure}[H]
    \centering
    \includegraphics[width=.70\linewidth]{figures/closedopenloop.jpg}
    \caption{Open Loop System Versus a Closed Loop System \cite{OCLoop}}
    \label{fig:loops}
\end{figure}

\subsection{Problem Investigation}
The measure of a successful closed-loop system is merited by its degree to which the measured final value compares to its target value after the system responds to a disturbance. This success can be measured by multiple characteristics of the system response. One such characteristic is the maximum error, a value which corresponds to the initial overshoot of the system response \cite{OCLoop}. Another valuable criteria is the response time and the settling time of the  system; the time from which an error is detected to when a corrective action is taken, and the time taken for the controller to complete its corrective path, respectively. After the final value is obtained, the steady state error is observable - the absolute difference of the final measured value and the ideal value, see the figure below for this visual representation (Figure \ref{fig:Resp}).
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{figures/System response.JPG}
    \caption{System Measurement - System Response to Disturbances  \cite{OCLoop}}
    \label{fig:Resp}
\end{figure}

State Space Modelling is the selected model implementation, ergo using the "notations of state, inputs, outputs and dynamics to describe the behavior of a system"\cite{StateSpace}. From the perspective of an unstable system, state modelling allows us to predict the behavior of the system. Partner this with real time feedback, and one is able to implement a state feedback controller to achieve a desired objective. In our case, stabilization of an inverted pendulum.
\subsection{Proposed Approach}
Overall, the system is composed of the following components:\\
\textbf{Mechanical}
\begin{itemize}
    \item Cart linear guide rail from printer cartridge actuator
    \item DC motor and belt drive from printer cartridge actuator
    \item Custom built cart of spare mechanical parts
    \item Potentiometer mounted to cart
    \item Pendulum built from mechanical flange and spare parts at the top for weight
\end{itemize}
\textbf{Electronics}
\begin{itemize}
    \item TM4C123GH6PM microcontroller
    \item 10k$\Omega$ potentiometer
    \item Linear optical quadrature encoder and optical strip
    \item Arduino development kit wires and breadboard for connections
\end{itemize}
\subsubsection{System Integration with PID Control}
Once the system setup and software architecture was completed (initialization, handlers, variables, etc.), the first type of controller that was implemented was a proportional-integral-derivative (PID) controller, a basic, practical controller that will enable verification that the entire system is functioning properly. The following figure displays the overall control dynamics of a PID controller.
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{figures/pid.png}
    \caption{PID Control \cite{pid}}
    \label{fig:Resp}
\end{figure}
Once sensors, handlers and all supporting functions have been tested, we can move on to developing a more complex controller via the course material of MSE 483.
\subsubsection{LQR Control}
Following the initial implementation of this control system, a more enhanced linear-quadratic-regulator controller will be implemented. This system, though similar in practicality to a PID controller, employs a more optimal approach to gain tuning. The following equation represents the controller output \textit{u}, which effectively sets the duty cycle of the motor PWM signal, can be seen below.
\begin{equation}
    u = -Kx + r
\end{equation}
Where the values of K will be tuned in MATLAB. In order to model our system accurately in MATLAB, each constant of the system must be measured and recorded (see section \ref{record}). For example, the cart weight, pendulum inertia, length and more have significant impacts on the modelling of the system, including the controllability and observability. Section \ref{theory} outlines the theoretical knowledge for said controller. Once these values are recorded, MATLAB will also be used to tune the gain vector \textit{L}, also known as the Luenberger observer.
\subsection{Proposed Expected Outcomes}
We expect to obtain a system response and from observing its characteristics previously explained, we plan to manipulate the system to minimize the steady state error. This error  responds to a system gain, however it is important to balance the increase of gain to the system as it impacts the sensitivity of the response and may additionally result in the increase of the maximum error and/or settling time \cite{OCLoop}. A critically damped system with a medium gain is most desirable. This can be observed through an ideal physical system producing minimum oscillation about the set point to counteract the moment created by the movement of the pendulum's center of mass. From this experiment we also aim to form a solidified concept of embedded computer control system programming; designing and building a system, integrating hardware and software for an embedded control application.

\section{System Design}
\subsection{Objectives}
\label{obj}
The goal of this controller aims to maintain the pendulum in a state of inversion, that is, an angle of $\theta = 180^o$, constantly and for various impulse forces to the pendulum, by changing the position ($x$) of the cart. See figure \ref{fig:pend} below.
\begin{figure}[H]
    \centering
    \includegraphics[width=.4\linewidth]{figures/pend.png}
    \caption{System Concept - Inverted Pendulum on a Cart \cite{inv}}
    \label{fig:pend}
\end{figure}

\textbf{Variables}
\begin{itemize}
    \item $x$ the position of the cart
    \item $\theta$ the angle of the pendulum
    \item $F$ applied forces to the cart
    \item $M, m$ masses of the cart, pendulum
    \item $l, I$ length and inertia of the pendulum
\end{itemize}
\subsubsection{Nice to Have's}
\label{nice}
In addition the the objectives outline in the previous section, there are many sub-features that can be developed in the software of this system that present complex control theory problems, 2 of which are outlined below.
\begin{itemize}
    \item Side-stepping of cart to a desired position ensuring constant pendulum stability.\\ \indent - For example, move cart from $x=0cm$ to $x=10cm$ with minimal overshoot, rise time, steady state error.
    \item Swing-up and swing-down commands\\ \indent - Enables the system to move the cart from one state of stability to another, ie. from $\theta =0^o$ to $\theta =180^o$ and stabilize, or vice versa with minimum oscillation.
\end{itemize}
\subsection{Theory}
\label{theory}
\subsubsection{Control Model}
MSE 483 - Modern Control Systems / Intro to State Space Control Systems - effectively outlines the process of implementing a state space model based control system. Physical systems possess many non-linearities and thus more practical models and tuning will need to be implemented. Such as the problem of the nonlinear control of an inverted pendulum, which sees to balance the pendulum from an unstable equilibrium position. Such controls methods include Linear Quadratic Regulation (LQR), observer based state feedback control and more. The following flowchart displays the proposed observer based state feedback control model, implementing an observer due to the fact that the system does not provide full state feedback, which would require the purchase of 2 tachometers to measure the rate of change of $\theta, x$, that is, $\dot{\theta}, \dot{x}$. However, we will be implementing a state estimator to estimate the values of these states instead.
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\linewidth]{figures/flow.png}
    \caption{Observer Based State Feedback Model to be Implemented \cite{inv2}}
    \label{fig:fc}
\end{figure}
The above control system will not be elaborated too in depth as it is out of the scope of this report, however it presents the overall concept. The most important variables and what they represent are discussed in the following:
\begin{itemize}
    \item $x$ the states of the system - $x, \dot{x}, \theta, \dot{\theta}$, measured and estimated through observer based state feedback.
    \item $y$ the demanded outputs of the controller, $x, \theta$
    \item $u$ the inputs to the system, which would be the force to the cart, $F$.
    \item $K, L$, the gain vector and Luenberger observer vector, designed and tuned in MATLAB.
    \item All other matrices, $A, B, C, D$ and so forth, represent the complete state model for the linearized system, full form shown below:
\end{itemize}
\begin{equation}
    \dot{x} = Ax + Bu \textrm{ and }
    y = Cx + Du
\end{equation}
And for the state estimator:
\begin{equation}
    \dot{\hat{x}} = A\hat{x} + Bu + L(y-\hat{y}) \textrm{ and }
    \dot{e} = \dot{x} - \dot{\hat{x}} = ... \implies \dot{e} = (A - LC)e
    \label{eq}
\end{equation}
Who's poles will be designed as 5-10 times faster than that of the LQR controller, so as to drive \textbf{$e\implies0$} as fast as possible.
\subsection{Methods}
\subsubsection{Experimentation}
To evaluate the proposed control models, experimentation will roughly proceed as follows:
\begin{enumerate}
    \item Power on the microcontroller with latest code developments.
    \item Normalize the cart position and pendulum angle (move cart to center of guide rail, hold pendulum vertically).
    \item Press SW1 on board to trigger interrupt, thus set run mode to TRUE, release the pendulum and evaluate controller effectiveness / stability.
    \item Introduce minor disturbances to the pendulum and the cart, evaluate system response.
\end{enumerate}
    
\subsubsection{Requirements}
The requirements for this problem are short and sweet - to balance the pendulum vertically as opposed to letting it fall over due to gravity. To elaborate on these requirements, we can set the following parameters:
\begin{itemize}
    \item $\Delta \theta < 5^o$ for small impulses to the pendulum or cart.
    \item Settling time of $< 4$ seconds.
    \item Cart position should be settled consistently at a constant location, ie. $x=0cm$.
\end{itemize}
Further requirements may be set for the "Nice to Have's" outlined in section \ref{nice}, depending on the project's completion schedule. Assuming all prior requirements are complete, we will investigate said problems and construct design requirements. 

\section{Implementation}
\subsection{Hardware}
\subsubsection{Mechanical}
As for the hardware of the inverted pendulum system, the re-purposed Canon printer can be seen throughout the following figures.

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5674.jpg}
  \caption{DC Motor Belt Drive}
  \label{fig:dc}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5807.jpg}
  \caption{Optical Encoder Linear Strip}
  \label{fig:opt}
\end{subfigure}
\caption{DC Motor Belt and Feedback}
\end{figure}

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5831.jpg}
    \caption{System Setup with Wiring}
    \label{fig:wire}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5848.jpg}
    \caption{System Electronics}
    \label{fig:elec}
\end{subfigure}
\caption{System Setup Development}
\end{figure}

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5874.jpg}
  \caption{Potentiometer on Cart}
  \label{fig:cart}
\end{subfigure}%
\begin{subfigure}{.36\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{figures/IMG_5871.jpg}
  \caption{Optical Encoder on Cart}
  \label{fig:cart2}
\end{subfigure}
\caption{Custom Built Low Friction Linear Guided Cart}
\end{figure}

\subsubsection{Electrical}
The Tiva TM4C123GH6PM microcontroller from Texas Instruments will be used as the real-time embedded controller. Code Composer Studio 9.3.0 for Mac OS X will be used to program and debug the board. A basic breadboard will be used for all wiring connections, and the course H-Bridge motor driver interface board will be used for PWM 12VDC motor control. A circuit drawing can be seen below, where $V_{CC}$ = 3.3V.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
                %Global Config
                font=\small
            ]
        %You can create an smart objet like Henry Menke in this post http://www.texample.net/tikz/examples/4-bit-counter/
        % Variables: 1: Position 2: ID.
         \def\TIVA(#1)#2{%
          \begin{scope}[shift={(#1)}]
            \draw[fill=red!10] (-1.5,-2) rectangle (1.5,2); % The body of IC
            \draw[blue] (0,0.6) node [align=center]{TIVA\\TM4C123}; % IC LABEL
            % Draw the pins
            % Some that you have to learn about label nodes, draw lines, and name coordinates in Tikz
            
            
            \draw (0.9,-2) node [above]{GND} -- +(0,-0.5) node [anchor=-45] coordinate (GND); % Pin 1 GND
            %\draw (1.5,0) node [left]{OUT} -- +(0.5,0) node [anchor=-45] coordinate (OUT); % Pin 3 OUT
            \draw (-1.5,1.5) node [right]{PB4} -- +(-0.5,0) node [anchor=-135] coordinate (PB4);
            \draw (-1.5,-0.5) node [right]{PD6} -- +(-0.5,0) node [anchor=-135] coordinate (PD6);
            \draw (-1.5,-1.0) node [right]{PD7} -- +(-0.5,0) node [anchor=-135] coordinate (PD7);
            \draw (1.5,0.0) node [left]{PE4} -- +(0.5,0) node [anchor=-45] coordinate (PE4);
            \draw (1.5,-0.5) node [left]{PE5} -- +(0.5,0) node [anchor=-45] coordinate (PE5);
            
            \draw (0,2) node [below]{$\mathsf{V_{CC}}$} -- +(0,0.5) node [anchor=45] coordinate (VCC2); % Pin 8 VCC
          \end{scope}
        }
        
         \def\HB(#1)#2{%
          \begin{scope}[shift={(#1)}]
            \draw[fill=blue!10] (-1.5,-2) rectangle (1.5,2); % The body of IC
            \draw[blue] (0,0.5) node [align=center]{\large h-Bridge}; % IC LABEL
            % Draw the pins
            % Some that you have to learn about label nodes, draw lines, and name coordinates in Tikz
            
            
            \draw (0.9,-2) node [above]{GND} -- +(0,-0.5) node [anchor=-45] coordinate (GNDHB); % Pin 1 GND
            %\draw (1.5,0) node [left]{OUT} -- +(0.5,0) node [anchor=-45] coordinate (OUT); % Pin 3 OUT
            \draw (-1.5,0.0) node [right]{HB1} -- +(-0.5,0) node [anchor=-135] coordinate (HB1);
            \draw (-1.5,-0.5) node [right]{HB2} -- +(-0.5,0) node [anchor=-135] coordinate (HB2);
            \draw (1.5,0.0) node [left]{M+} -- +(0.5,0) node [anchor=-45] coordinate (M+);
            \draw (1.5,-0.5) node [left]{M-} -- +(0.5,0) node [anchor=-45] coordinate (M-);
            
            \draw (0,2) node [below]{12V} -- +(0,0.5) node [anchor=45] coordinate (12V); % Pin 8 VCC
          \end{scope}
        }
        
        \def\OPT(#1)#2{%
          \begin{scope}[shift={(#1)}]
            \draw[fill=green!10] (-1,-1.5) rectangle (1,1); % The body of IC
            \draw[blue] (-0.5,0.5) node [align=center]{\large Opt.\\Enc.}; % IC LABEL
           
            \draw (1.0,0.0) node [left]{Ch.A} -- +(0.5,0) node [anchor=-45] coordinate (CHA);
            \draw (1.0,-0.5) node [left]{Ch.B} -- +(0.5,0) node [anchor=-45] coordinate (CHB);
            
            \draw (1.0,0.5) node [left]{$\mathsf{V_{CC}}$} -- +(0.5,0) node [anchor=-45] coordinate (VENC);
            \draw (1.0,-1.0) node [left]{GND} -- +(0.5,0) node [anchor=-45] coordinate (GNDENC);
            
          \end{scope}
        }
        
        
        % Start drawing the circuit: Example "Dee-Dah" Siren
        
        % Place the IC's in position
        \TIVA(0,0){1}
        \HB(4,0){1}
        \OPT(-4,-0.5){1}
        %Place polarization nodes:
        \draw (-6,3.5) node[ocirc] (VCC){} node[left]{$\mathsf{V_{CC}}$};
        \draw (-6,-4) node[ocirc] (GND2){} node[left]{GND};
        % Connect U-1
        \draw(VCC) % Start point
            to [short, o-] ++(0.5,0) coordinate (NOD1) % Use auxiliar coordinate (NOD1)
            to [pR, n=POT] (PB4 -| NOD1) % to the point in the intersection between NOD1 and 1 DIS
            to [short] (GND2 -| NOD1)
            to [short] (GND2);
    
        
        %\draw(VCC2) to [short] (VCC);
        \draw(GND) to [short] (GND |- GND2) to [short] (GND2 -| NOD1);
        \draw(GNDHB) to [short] (GNDHB |- GND2)  to [short] (GND |- GND2);
        \draw(GNDENC) to [short] (GNDENC |- GND2);
        \draw[short] (NOD1) -| (VCC2)
        \draw[short] (POT.wiper) -| (PB4)
        \draw(VENC) to [short] (VENC |- VCC);
        \draw[short] (CHA) -| (PD6)
        \draw[short] (CHB) -| (PD7)
        \draw (8,-0.2) node[elmech](motor){M};
        \draw[short] (motor.north) -| (M+)
        \draw[short] (motor.south) -| (M-)
        
        %Place input/output nodes
        % \draw[color=blue,line width=2] (1 TRG) to [short] ++(-0.55,0) node[ocirc] (TRG){} node[below]{Trigger};
        \draw[color=red,line width=2] (12V) to [short] ++(0,0.55) node[ocirc](12V){} node[left]{12V};
    
    \end{tikzpicture}
    

    \caption{Circuit Drawing}
    \label{fig:circ}
\end{figure}



\begin{figure}[H]
    \centering
    \includegraphics[width=.8\linewidth]{figures/DSC01795.jpg}
    \caption{Completed System Electronics}
    \label{fig:elec}
\end{figure}


\subsubsection{Completed System}
% \begin{figure}
% \centering
% \begin{circuitikz} \draw
% (0,0) to [V, v=$v(t)$, *-*] (0,2) 
%     to [R, l=$R_d$] (2,2)
%     to [L, l=$L_d$] (4,2)
%     to [V, v<=$e(t)$] (4,0) to [generic] (4,2) -- (4,0) -- (0,0);
% \end{circuitikz}
% \end{figure}
% \begin{tikzpicture}
% \ctikzset{tripoles/mos style=arrows}
% \ctikzset{transistors/arrow pos=end}
% \draw(1,-3) to[short] (1,1)
%  (0,-1) to[short] (2,-1)
%  (0,-1.5) to[short] (0,-0.5);
% \draw (0,0) node[npn, ](npn){}; 
% \ctikzset{diodes/scale=0.6}
% \draw (2,-1) to[D, l=$D1$] ++(0,2);
% \draw (0,-2) node[pnp, ](npn){};
% \draw (2,-3) to[D, l=$D2$] ++(0,2);
% \end{tikzpicture}
\begin{figure}[H]
    \centering
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/DSC01784.JPG}
      \caption{Complete System}
      \label{fig:comp}
    \end{subfigure}%
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/DSC01778.JPG}
      \caption{Linear Cart with Optical Strip}
      \label{fig:compstrip}
    \end{subfigure}
    \caption{Built Inverted Pendulum System}
    \label{fig:invDone}
\end{figure}



\subsection{Software}
To develop the state space model analysis, software tools MATLAB and SIMULINK will be used. MATLAB to develop the system state model, test and implement observer based feedback control, and SIMULINK to simulate and test the system, as well as fine tune the control gains. Furthermore, the controllability and observability of the system can be assessed in MATLAB, and will be discussed in the final project report.

\subsubsection{Control System Flowchart}

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=green!20, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em]

\begin{figure}[H]
    \centering
    \footnotesize
    \begin{tikzpicture}[node distance = 2cm, auto]
    
        % Place nodes
        \node [block] (init) {initialize system};
        \node [cloud, left of=init] (obsvh) {obsv.h};
        \node [cloud, right of=init, node distance=6cm] (hand) {peripherals, ISRs};
        \node [block, below of=init] (eval) {evaluate inputs};
        \node [decision, below of=eval] (decide) {run mode and inverted?};
        \node [block, below of=decide, node distance=3cm] (eval2) {evaluate inputs};
        \node [block, left of=eval2, node distance=3cm] (dc0) {set 0\% duty cycle};  
        \node [block, below of=dc0, node distance=2cm] (loop2) {loop};  
        \node [block, below of=eval2, node distance=2cm] (obsv) {run observer};
        \node [block, below of=obsv, node distance=2cm] (dc) {LQR $\implies$ duty cycle};
        \node [block, below of=dc, node distance=2cm] (loop) {loop};
        \node [block, below of=hand, node distance=2cm] (pf) {port f handler};
        \node [block, below of=pf, node distance=2cm] (uart) {UART handler};
        \node [block, below of=uart, node distance=2cm] (qei) {QEI};
        \node [block, below of=qei, node distance=2cm] (adc) {ADC};
        
        % Draw edges
        \path [line] (init) -- (eval);
        \path [line] (eval) -- (decide);
        \path [line] (decide) -- node {yes}(eval2);
        \path [line] (eval2) -- (obsv);
        \path [line] (obsv) -- (dc);
        \path [line] (dc) -- (loop);
        \path [line] (dc0) -- (loop2);
        \path [line] (loop.east) -- ++(1.5,0) -- ++(0,1.5) -- ++(0,7.5) -- (decide.east);
        \path [line] (loop2.west) --  ++(-1.5,0) -- ++(0,2) -- ++(0,6) -- (eval.west);
        \path [line] (decide) -| node [near start] {no} (dc0);
        \path [line,dashed] (obsvh) -- (init);
        \path [line,dashed] (init) -- (hand);
        \path [line,dashed] (hand.east) |- (pf.east);
        \path [line,dashed] (hand.east) |- (uart.east);
        \path [line,dashed] (hand.east) |- (qei.east);
        \path [line,dashed] (hand.east) |- (adc.east);
        %\path [line,dashed] (obsvh) |- (eval);
        
    \end{tikzpicture}

    \caption{Controller Flowchart}
    \label{fig:flow}
\end{figure}


\subsubsection{Luenberger Observer Implementation}
To elaborate on our control model approach shown in figure \ref{fig:fc}, the following algorithm will be implemented in C to estimate the immeasurable states, $\dot{x}, \dot{\theta}$, the velocity of the cart and the rotational velocity of the pendulum.\\

\footnotesize
\begin{algorithm}[H]
    \SetAlgoLined
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Measured states, $x$}
    \Output{Estimated states, $\hat{x}$}
    Update observer state estimator global variables $\dot{x},\dot{\theta}$\\
    Based off measurements of $x,\theta$\\
    \bigskip
    $y = Cx$\\
    \While{e \geq \tau}{
        $\hat{y} = C\hat{x}$\\
        $e = y - \hat{y}$\\
        $\dot{\hat{x}} = (A-BK)\hat{x} + Le$\\
        dt = stopTimer();\\
        $\hat{x_{n}} = \hat{x} + \dot{\hat{x}}dt$\\
        $\hat{x} = \hat{x_{n}}$\\
        startTimer();
        }
    \caption{Luenberger Observer Algorithm}
\end{algorithm}

\normalsize
This algorithm implementation in C can be seen in appendix \ref{obsverver}.

\subsection{Gain Tuning}
There are various methods for tuning that are proven and that range in trial-and-error, iterative behaviour,  aggressiveness of tuning, process time etc. For the sake of simplicity and the completion of our proof of concept we resorted to a manual tuning method. 

\subsubsection{Recording Constants}
\label{record}
In order to tune the gains of our system effectively, an accurate simulation model had to be created in MATLAB. For this to happen, all characteristics of the system, including the pendulum mass, inertia, cart mass, and more, had to be measured. In the case of cart friction, estimated.
\begin{figure}[H]
    \centering
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/weigh1.jpg}
      \caption{Pendulum Mass}
      \label{fig:pMass}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/weigh2.jpg}
      \caption{Cart Mass}
      \label{fig:cMass}
    \end{subfigure}
    \caption{Measurement of System Constants}
    \label{fig:measure}
\end{figure}
All resulting MATLAB code can be seen in the \textit{model.m} on Github \cite{github}.
\subsubsection{Modelling System Responses}
After completing the state model for the linearized system, as discussed in section \ref{obj}, the model was then implemented and simulated in MATLAB. This allows for software-in-the-loop testing of the system, without the concerns of breaking hardware, sensor noise, non-linearities and more. However, this can pose as a risk as the system simulation accuracy cannot be exact, due to said non-linearities that only exist in a physical system, such as friction, motor back EMF, and more. Figure \ref{fig:sim} shows the simulated system response for a cart position step input of \textit{20cm}.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/models.png}
    \caption{Observer Based State Feedback System Simulated Response in MATLAB}
    \label{fig:sim}
\end{figure}
    
\section{Results}

\subsection{Tuning Process}
Once the system was completely setup and tested with PID control, development and testing of the observer had to be streamlined. Rather than tuning in MATLAB, copying and pasting system matrices, a function was developed in MATLAB to export the \textit{obsv.h} file, containing said constants. This file can be seen in appendix \ref{obsvh}.

\begin{figure}[H]
    \centering
    \footnotesize
    \begin{tikzpicture}[node distance = 2cm, auto]
    
        % Place nodes
        \node [block] (model) {initialize model};
        \node [cloud, above of=model, node distance=2.5cm] (system) {system model};
        \node [block, right of=model, node distance=2.5cm] (tune) {tune \textit{K, L}};
        \node [block, right of=tune, node distance=2.5cm] (export) {export model (\textit{obsv.h})};
        \node [block, right of=export, node distance=2.5cm] (test) {test tiva system};
        \node [decision, right of=test] (tuned) {stable pendulum?};
        \node [cloud, right of=tuned] (done) {done};
        
        % Draw edges
        \path [line] (system) -- (model);
        \path [line] (model) -- (tune);
        \path [line] (tune) -- (export);
        \path [line] (export) -- (test);
        \path [line] (test) -- (tuned);
        \path [line] (tuned) -- node {yes}(done);
        \path [line] (tuned.south) -| node {no}(model.south);
    \end{tikzpicture}

    \caption{Tuning Process Flowchart}
    \label{fig:tune}
\end{figure}

\subsection{Stability and Response Characteristics}
Overall, the physical system is very controllable. Adequate sensors and a powerful motor enable the robust, real time embedded control of the inverted pendulum system. However, the issue lies in the implementation of the observer. As discussed earlier and seen in figure \ref{fig:fc}, the Luenberger observer is a complex system that takes time to tune and test, and is out of the scope of this report. Currently, the error variable, \textit{e} (see equation \ref{eq}), diverges to infinity, and consulting with the MSE 483 course TA is underway.\\\\
Instead, the basic response characteristics and results will be observed for the basic PID controller. Figure \ref{fig:step} displays the states of the system, $x, \theta$, as the pendulum responds to minor impulses.
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{figures/nice.png}
    \caption{Physical System Response}
    \label{fig:step}
\end{figure}
It can be seen above that as the pendulum angle moves further from 0, the cart's position is adjusted by the motor in order to ensure the pendulum remains stable. At most, the pendulum angle moves 0.08 radians, approximately 4.58$^o$, which satisfies the controller requirements. Moreover, a settling time of $\leq$ 4 seconds is clear, however there exists steady state error with respect to the cart's position. After a quick analysis of controllability of an inverted pendulum using PID control, it can be seen that there will always exist steady state error for the cart position \cite{pidBad}, hence the demand for a state feedback type controller.
\\\\
After the manual tuning method was implemented, the system ended up with a relatively satisfactory proportional gain for a "P" controller. As the gain for "P" ($K_P$) increases, the most observable effects are the decrease in rise time, increase in overshoot, decrease in steady state error, and a degrade in the stability of the system with an overall small change in settling time. After the manual manipulation of $K_P$, the settled upon gain after a few attempts was a value of $800$.  
\subsection{Additional System Enhancements}
This section outlines the modifications that were made to the system to solve problems that were discovered throughout the development of the project.

\subsubsection{Potentiometer Short Circuiting}
After tireless troubleshooting it was found that there was a faulty connection in the wiring for the potentiometer. The following figures display the noise induced by this error, and it's effect on the system performance. It can be seen that the cart was incredibly 'jumpy' prior to the re-wiring of the sensor.
\begin{figure}[H]
    \centering
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/IMG_5968.jpg}
      \caption{Faulty Connection}
      \label{fig:conn}
    \end{subfigure}
    \begin{subfigure}{.4\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/noise.png}
      \caption{Resulting Noise}
      \label{fig:noise}
    \end{subfigure}
    \caption{Faulty Connection Potentiometer Noise}
    \label{fig:senNoise}
\end{figure}

\subsubsection{Moving Average Filter for ADC Data}
When using an analog to digital converter, there is often a large amount of signal noise present, especially when using a cheap Arduino kit potentiometer. Thus, signal filtering is required. Rather than implementing an RC filter and delaying the signal with too large of a capacitor, we implemented a simple moving average filter. The following images display the before and after signal conditioning results.
\begin{figure}[H]
    \centering
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/noAvg.png}
      \caption{No Filter}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/movAvg10.png}
      \caption{Moving Average, Length 10}
    \end{subfigure}
    \begin{subfigure}{.6\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{figures/movAvg25.png}
      \caption{Moving Average, Length 25}
    \end{subfigure}
    \caption{ADC Signal Noise Moving Average Filtering}
    \label{fig:filter}
\end{figure}


\subsubsection{Quadrature Encoder Interface}
The Quadrature Encoder Interface (QEI) module provides an interface for which incremental encoders - such as the one used in this project- is able to obtain the mechanical position of the data \cite{qei}. Below is an image which illustrates the signals produced by a QEI (figure \ref{fig:qei}). These encoders are also known as optical encoders and characteristically have two signals which are out of phase (one leading and one lagging). Since the digital interrupt protocol for QEI outputs were not fast enough to increase or decrease the cart's position, the on board QEI hardware was implemented. This was able to essentially read the cart's position separate from the main CPU. 

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{figures/qei.JPG}
    \caption{Quadtrature Encoder Interface Signal}
    \label{fig:qei}
\end{figure}

\subsubsection{UART Data Transmission to MATLAB}
Rather than using Code Composer Studio's low quality graphical interface, that does not allow for recording of data, plot editing and more, UART communication was implemented on the board to enable plotting and analysis in MATLAB. Upon interrupt trigger, the board sends the current readings for $x$ and $\theta$, rather than constantly sending the data, even if no devices are listening. After a few lines of code, a loop allows MATLAB to poll these values from the board over a set period, convert them from hex to decimal, and plot. Code for the UART interrupt handler function can be seen in appendix \ref{uart}.


\section{Conclusions}
Overall, this system is completely feasible, controllable and observable. Within this design project we were able to provide thorough testing that was completed with all proposed components and ensured satisfactory working requirements to implement the state controller. Furthermore, proposed GPIO for the microcontroller has been completed and checked in the course lab experiments, hence all the required knowledge is possessed. Issues that arose included the mechanical development and construction of the system requiring the complete deconstruction of the cart to be rebuilt in order create smoother movement. Furthermore, the optical encoder needed to be replaced as the old component salvaged from the printer was inevitably burnt out. Difficulties with protocol implementation included UART and PWM. UART was difficult to implement at first but was soon remedied after further research and the PWM load cycle took a while to integrate during our experimentation but was able to run successfully by the end. 
\\\\
As for the implementation of the Luenberger observer state feedback controller, the tuning is nearing completion. An online session has been scheduled with the MSE 483 TA to ensure the convergence of the error variable, \textit{e}, to 0. Once this is completed, the system can be further tuned for quick response time, 0 steady state error and more. State space modelling in MATLAB has enabled the proper assessment of controllability and observability of the system, as well as tuning of the LQR controller. Pole placement is key in control system development, and functions such as \textbf{place} and \textbf{acker} enhance this process.
\\\\
In terms of tuning the PID controller, a more standardized method of tuning could have been implemented such as the \textit{Zielgler-Nicolas method} as opposed to finding an experimentally sufficient gain. Our approach was able to find a well-fitting proportional "P" gain, however we did not implement a fully developed gain for a proportional, derivative and integral "PID" controller. Regardless our main design goals were ultimately met, this is rather a suggestion for bettering the experiment in the future. 
\\\\
Finally, the timeline earlier proposed (appendix A),  was for the most part kept on schedule and successfully implemented. From this experiment, topics of embedded systems thoroughly explored were interrupts, ADC, PWM, and integration of design - to name a few.
\\\\
All to date development can be seen on Github \cite{github}, on branch \textbf{master}. Gain tuning and Luenberger observer testing can be seen on branch \textbf{gain-tuning}, and will be merged once completed. Folder \textbf{matlab/} discusses system analysis, controllability and observability. Folder \textbf{tiva/} contains all \textbf{C} code for the microcontroller board and Code Composer Studio.

\newpage
% ADD BIBLIOGRAPHY
\nocite{*}
\bibliographystyle{IEEE/IEEEtran}
\bibliography{IEEE/IEEEabrv,IEEE/biblio}

\newpage
\appendix
\section{Timeline}
It has been decided upon that the project duration will last approximately 1 month, to ensure completion of the working control system before the due date. The following timeline shows the approximate estimated dates for each major phase of the project. It should be noted that some tasks will be completed in parallel rather than in series, when possible. The remaining dates of April 1 - 10 will be used for tuning the controller with MATLAB and testing.\\

\begin{chronology}[5]{1}{30}{\textwidth}
\event{1}{Project Kick-off}
\event[1]{5}{Mechanical Setup}
\event[5]{8}{Wiring and Electronics}
\event[8]{11}{Integration Testing}
\event[11]{15}{Initialization (PWM, ADC, etc.)}
\event{15}{Individual Component Control Complete}
\event[15]{20}{BG Functions (Interrupts, ADC, etc.)}
\event{20}{System Implementation Complete}
\event[20]{25}{Control Model Development}
\event[25]{30}{Testing and Fine Tuning}
\event{30}{Project Deadline}
\end{chronology}
\textbf{Project Timeline for the Month of March, by Day}\\

\section{Observer Function in C}
\label{obsverver}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{c}
void obsv(void){
    y.X = (pos - ref.X)*scalePos;
    y.Y = (theta - ref.Z)*scaleTheta;

    yHat.X = HMM_DotVec4(C1, xHat);
    yHat.Y = HMM_DotVec4(C2, xHat);

    e = HMM_SubtractVec2(y, yHat);

    xHatDot.X = HMM_DotVec4(ABK1, xHat) + HMM_DotVec2(L1, e);
    xHatDot.Y = HMM_DotVec4(ABK2, xHat) + HMM_DotVec2(L2, e);
    xHatDot.Z = HMM_DotVec4(ABK3, xHat) + HMM_DotVec2(L3, e);
    xHatDot.W = HMM_DotVec4(ABK4, xHat) + HMM_DotVec2(L4, e);


    dt = stopTimer();

    xHatNext = HMM_AddVec4(xHat, HMM_MultiplyVec4f(xHatDot, dt));

    xHat = xHatNext;
    startTimer();

}
\end{minted}

\section{Observer Header in C}
\label{obsvh}
It should be noted that these actual gains were not implemented, only present at time of report development.
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{c}
//Gains for K, A-B*K, L from MATLAB
float k[4] = {-10,-10.7925,46.0882,7.94368};
float abk2[4] = {52.14475,55.60931,-239.0601,-41.42211};
float abk4[4] = {146.6096,156.7628,-651.391,-116.462};
float l1[2] = {430.0024,-162.9998};
float l2[2] = {5372.1669,-2736.4126};
float l3[2] = {-127.0637,177.8561};
float l4[2] = {3473.1059,110.9461};

\end{minted}

\section{UART Interrupt Handler in C}
\label{uart}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{c}

void UARTIntHandler(void)
{
    uint32_t ui32Status;
    // Get the interrupt status.
    ui32Status = UARTIntStatus(UART0_BASE, true);
    //
    // Clear the asserted interrupts.
    //
    UARTIntClear(UART0_BASE, ui32Status);

    //UARTSend((uint8_t *)"nah\r\n", 5);
    //
    // Loop while there are characters in the receive FIFO.
    
    while(UARTCharsAvail(UART0_BASE))
    {
        // Read the next character from the UART and write it back to the UART.
        UARTCharPutNonBlocking(UART0_BASE, UARTCharGetNonBlocking(UART0_BASE));
    }
    send_u32(theta_target - theta);
    send_u32(pos);
}
\end{minted}



\end{document}
